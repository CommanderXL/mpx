const compiler = require('./compiler')
const bindThis = require('./bind-this').transform
const parseRequest = require('../utils/parse-request')
const matchCondition = require('../utils/match-condition')
const isEmptyObject = require('../utils/is-empty-object')
const { transformSlotsToString } = require('../runtime-render/utils')
const loaderUtils = require('loader-utils')

const noCacheReg = /mpx-custom-element\.mpx|mpx-render-base\.wxml/

module.exports = function (raw) {
  const { resourcePath, queryObj } = parseRequest(this.resource)

  if (noCacheReg.test(resourcePath)) {
    this.cacheable(false)
  } else {
    this.cacheable()
  }

  const mpx = this.getMpx()
  const root = mpx.projectRoot
  const mode = mpx.mode
  const env = mpx.env
  const defs = mpx.defs
  const i18n = mpx.i18n
  const externalClasses = mpx.externalClasses
  const decodeHTMLText = mpx.decodeHTMLText
  const globalSrcMode = mpx.srcMode
  const localSrcMode = queryObj.mode
  const packageName = queryObj.packageRoot || mpx.currentPackageRoot || 'main'
  const componentsMap = mpx.componentsMap[packageName]
  const wxsContentMap = mpx.wxsContentMap
  const usingComponents = queryObj.usingComponents || []
  const hasComment = queryObj.hasComment
  const isNative = queryObj.isNative
  const hasScoped = queryObj.hasScoped
  const moduleId = queryObj.moduleId
  const componentsAbsolutePath = queryObj.componentsAbsolutePath || {}
  const runtimeComponents = queryObj.runtimeComponents || []
  const runtimeCompile = queryObj.runtimeCompile

  const warn = (msg) => {
    this.emitWarning(
      new Error('[template compiler][' + this.resource + ']: ' + msg)
    )
  }

  const error = (msg) => {
    this.emitError(
      new Error('[template compiler][' + this.resource + ']: ' + msg)
    )
  }

  const parsed = compiler.parse(raw, {
    warn,
    error,
    componentsAbsolutePath,
    runtimeComponents,
    runtimeCompile,
    usingComponents,
    hasComment,
    isNative,
    isComponent: !!componentsMap[resourcePath],
    mode,
    env,
    srcMode: localSrcMode || globalSrcMode,
    defs,
    decodeHTMLText,
    externalClasses,
    hasScoped,
    moduleId,
    filePath: this.resourcePath,
    i18n,
    checkUsingComponents: mpx.checkUsingComponents,
    globalComponents: Object.keys(mpx.usingComponents),
    forceProxyEvent: matchCondition(this.resourcePath, mpx.forceProxyEventRules) || runtimeCompile,
    hasVirtualHost: matchCondition(this.resourcePath, mpx.autoVirtualHostRules)
  })

  let ast = parsed.root
  let meta = parsed.meta

  if (meta.wxsContentMap) {
    for (let module in meta.wxsContentMap) {
      wxsContentMap[`${resourcePath}~${module}`] = meta.wxsContentMap[module]
    }
  }

  let resultSource = ''

  for (let module in meta.wxsModuleMap) {
    const src = loaderUtils.urlToRequest(meta.wxsModuleMap[module], root)
    resultSource += `var ${module} = require(${loaderUtils.stringifyRequest(this, src)});\n`
  }

  let result = compiler.serialize(ast, meta)

  if (isNative) {
    return result
  }

  // 生成 slots render 函数并注入到 runtime
  let injectSlots = {}
  try {
    if (meta.slotElements) {
      Object.keys(meta.slotElements).forEach(key => {
        injectSlots[key] = {}
        const astChildren = meta.slotElements[key]
        astChildren.map(node => {
          const slotTarget = node.slotTarget
          if (slotTarget) {
            if (!injectSlots[key][slotTarget]) {
              injectSlots[key][slotTarget] = []
            }
            const rawRenderFn = compiler.genElement(node, usingComponents)
            const code = bindThis(rawRenderFn, {
              needCollect: true,
              ignoreMap: meta.wxsModuleMap
            }).code
            injectSlots[key][slotTarget].push(code.slice(0, -1))
          }
        })
      })
    }
  } catch (e) {
    error(`Invalid slot render function generated by the template, please check!\n
        Error Detail:
        ${e.stack}`)
    return result
  }

  let bindResult

  if (runtimeCompile) {
    // 运行时编译组件返回内容，render 函数内部执行会生成 virtual dom tree
    let renderFn = compiler.genElement(ast)
    try {
      bindResult = bindThis(renderFn, {
        needCollect: true,
        ignoreMap: meta.wxsModuleMap
      })
      bindResult.code = `global.currentInject = {
        moduleId: ${JSON.stringify(moduleId)},
        render: function () {
          var vnode = ${bindResult.code}
          this._r(vnode)
        }
      };\n`
    } catch (e) {
      error(`Invalid render function generated by the template, please check!\n
        Error Render Function:
        ${renderFn}
        Error Detail:
        ${e.stack}`)
      return result
    }
  } else {
    const rawCode = `global.currentInject = {
      moduleId: ${JSON.stringify(moduleId)},
      render: function () {
        ${compiler.genNode(ast)}
        this._r();
      }
    };\n`
    try {
      bindResult = bindThis(rawCode, {
        needCollect: true,
        ignoreMap: meta.wxsModuleMap
      })
    } catch (e) {
      error(`Invalid render function generated by the template, please check!\n
        Template result:
        ${result}\n
        Error code:
        ${rawCode}
        Error Detail:
        ${e.stack}`)
      return result
    }
  }

  resultSource += bindResult.code + '\n'

  if ((mode === 'tt' || mode === 'swan') && bindResult.propKeys) {
    resultSource += `global.currentInject.propKeys = ${JSON.stringify(bindResult.propKeys)};\n`
  }

  if (runtimeCompile) {
    resultSource += `global.currentInject.runtimeCompile = true;\n`
  }

  if (!isEmptyObject(injectSlots)) {
    let data = '{'
    Object.keys(injectSlots).map(key => {
      data += `'${key}': ${transformSlotsToString(injectSlots[key])},`
    })
    data += '}'
    resultSource += `global.currentInject.runtimeSlots = function () {
      return ${data}
    };\n`
  }

//   const rawCode = `
// global.currentInject = {
//   moduleId: ${JSON.stringify(moduleId)},
//   render: function () {
//     ${compiler.genNode(ast)}
//     this._r();
//   }
// };\n`

//   let bindResult

//   try {
//     bindResult = bindThis(rawCode, {
//       needCollect: true,
//       ignoreMap: meta.wxsModuleMap
//     })
//   } catch (e) {
//     error(`
// Invalid render function generated by the template, please check!\n
// Template result:
// ${result}\n
// Error code:
// ${rawCode}
// Error Detail:
// ${e.stack}`)
//     return result
//   }

//   resultSource += bindResult.code + '\n'

//   if ((mode === 'tt' || mode === 'swan') && bindResult.propKeys) {
//     resultSource += `global.currentInject.propKeys = ${JSON.stringify(bindResult.propKeys)};\n`
//   }

  if (meta.computed) {
    resultSource += bindThis(`
global.currentInject.injectComputed = {
  ${meta.computed.join(',')}
};`).code + '\n'
  }

  if (meta.refs) {
    resultSource += `
global.currentInject.getRefsData = function (needRuntimeRef) {
  return ${JSON.stringify(meta.refs)}.filter(function (ref) { return !!ref.runtimeRef === !!needRuntimeRef });
};\n`
  }

  this.emitFile(resourcePath, '', undefined, {
    skipEmit: true,
    extractedResultSource: resultSource
  })

  // 运行时编译的组件直接返回动态模板的内容
  if (runtimeCompile) {
    const src = loaderUtils.stringifyRequest(this, require.resolve('../runtime-render/mpx-render-base.wxml'))
    return `<import src=${src}/> <template is="mpx_tmpl" data="{{ r: r }}"></template>`
  }

  return result
}
